syntax = "proto3";

package temporal.v1;
option go_package = "./pb/v1";


message TemporalReq{

}
message TemporalReply{

}


// Temporal服务定义
service TemporalService {
  // 启动工作流
  rpc StartWorkflow(StartWorkflowRequest) returns (StartWorkflowResponse) {}

  // 取消工作流
  rpc CancelWorkflow(CancelWorkflowRequest) returns (CancelWorkflowResponse) {}

  // 发送信号到工作流
  rpc SignalWorkflow(SignalWorkflowRequest) returns (SignalWorkflowResponse) {}

  // 获取工作流执行状态
  rpc GetWorkflowExecution(GetWorkflowExecutionRequest) returns (GetWorkflowExecutionResponse) {}

  // 创建定时任务
  rpc StartScheduleTask(ScheduleTaskRequest) returns (ScheduleTaskResponse) {}

  // 批量取消工作流
  rpc BatchCancelWorkflows(BatchCancelWorkflowRequest) returns (BatchCancelWorkflowResponse) {}

  // 批量创建定时任务
  rpc BatchStartScheduleTasks(BatchScheduleTaskRequest) returns (BatchScheduleTaskResponse) {}

  // 创建自定义调度
  rpc CreateSchedule(ScheduleOptions) returns (TemporalReply) {}
}


// 任务类型的枚举
enum ScheduleTaskType {
  UNDEFINED = 0;               // 未定义（默认值）
  GRAYLIST_EXPIRE_TASK = 1;    // 灰名单失效任务
  WHITELIST_EXPIRE_TASK = 2;   // 白名单失效任务
}

// 工作流执行状态
enum WorkflowExecutionStatus {
  WORKFLOW_EXECUTION_STATUS_UNSPECIFIED = 0;
  WORKFLOW_EXECUTION_STATUS_RUNNING = 1;
  WORKFLOW_EXECUTION_STATUS_COMPLETED = 2;
  WORKFLOW_EXECUTION_STATUS_FAILED = 3;
  WORKFLOW_EXECUTION_STATUS_CANCELED = 4;
  WORKFLOW_EXECUTION_STATUS_TERMINATED = 5;
  WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW = 6;
  WORKFLOW_EXECUTION_STATUS_TIMED_OUT = 7;
}


// 工作流 ID 重用策略枚举
enum WorkflowIdReusePolicy {
  // 未指定策略（默认）
  WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED = 0;

  // 允许使用相同的 workflow ID 启动新的 workflow
  WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE = 1;

  // 仅当上一次执行结果为终止、取消、超时或失败时才允许使用相同的 workflow ID 启动新的 workflow
  WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY = 2;

  // 不允许重复使用 workflow ID
  WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE = 3;

  // 与 ALLOW_DUPLICATE 类似，但如果有运行中的 workflow，则会终止当前的并启动新的
  WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING = 4;
}


// 启动工作流请求
message StartWorkflowRequest {
  string workflow_type = 1;       // 工作流类型
  string task_queue = 2;          // 任务队列
  string workflow_id = 3;         // 工作流ID(可选)
  bytes input = 4;                // 工作流输入参数(JSON编码)
  int64 timeout_seconds = 5;      // 超时时间(秒)
  WorkflowOptions options = 6;    // 工作流选项
}

// 工作流选项
message WorkflowOptions {
  int64 execution_timeout_seconds = 1;   // 执行超时(秒)
  int64 run_timeout_seconds = 2;         // 运行超时(秒)
  int64 task_timeout_seconds = 3;        // 任务超时(秒)
  repeated RetryPolicy retry_policy = 4;  // 重试策略
  string cron_schedule = 5; // 定时调度
}

// 重试策略
message RetryPolicy {
  int64 initial_interval_seconds = 1;    // 初始重试间隔(秒)
  double backoff_coefficient = 2;        // 退避系数
  int64 maximum_interval_seconds = 3;    // 最大重试间隔(秒)
  int32 maximum_attempts = 4;            // 最大重试次数
}

// 启动工作流响应
message StartWorkflowResponse {
  string workflow_id = 1;    // 工作流ID
  string run_id = 2;         // 运行ID
}

// 取消工作流请求
message CancelWorkflowRequest {
  string workflow_id = 1;   // 工作流ID
  string run_id = 2;        // 运行ID(可选)
  string reason = 3;        // 取消原因
}

// 取消工作流响应
message CancelWorkflowResponse {
  bool success = 1;         // 是否成功
}

// 发送信号请求
message SignalWorkflowRequest {
  string workflow_id = 1;     // 工作流ID
  string run_id = 2;          // 运行ID(可选)
  string signal_name = 3;     // 信号名称
  bytes signal_input = 4;     // 信号数据(JSON编码)
}

// 发送信号响应
message SignalWorkflowResponse {
  bool success = 1;           // 是否成功
}

// 获取工作流执行请求
message GetWorkflowExecutionRequest {
  string workflow_id = 1;     // 工作流ID
  string run_id = 2;          // 运行ID(可选)
}



// 获取工作流执行响应
message GetWorkflowExecutionResponse {
  string workflow_id = 1;                           // 工作流ID
  string run_id = 2;                                // 运行ID
  WorkflowExecutionStatus status = 3;               // 状态
  bytes result = 4;                                 // 结果(JSON编码，如果已完成)
  string error_message = 5;                         // 错误信息(如果失败)
  int64 start_time_unix = 6;                        // 开始时间(Unix时间戳)
  int64 close_time_unix = 7;                        // 结束时间(Unix时间戳，如果已结束)
}





// 定时任务请求
message ScheduleTaskRequest {
  string task_id = 1;               // 任务ID
  ScheduleTaskType task_type = 2;              // 任务类型
  int64 delay_seconds = 3;          // 延迟时间(秒)
  bytes data = 4;                   // 任务数据(JSON编码)
  WorkflowIdReusePolicy workflow_id_policy = 5;            // 工作流 ID 重用策略枚举
}



// 定时任务响应
message ScheduleTaskResponse {
  string workflow_id = 1;           // 工作流ID
  string run_id = 2;                // 运行ID
}

// 批量取消工作流请求
message BatchCancelWorkflowRequest {
  repeated CancelWorkflowRequest workflows = 1; // 需要取消的工作流列表
}

// 批量取消工作流响应
message BatchCancelWorkflowResponse {
  message Result {
    string workflow_id = 1;     // 工作流ID
    bool success = 2;           // 是否成功
    string error_message = 3;   // 错误信息(如果失败)
  }
  repeated Result results = 1;  // 每个工作流的取消结果
}

// 批量创建定时任务请求
message BatchScheduleTaskRequest {
  repeated ScheduleTaskRequest tasks = 1; // 需要创建的定时任务列表
}

// 批量创建定时任务响应
message BatchScheduleTaskResponse {
  message Result {
    string task_id = 1;        // 任务ID
    string workflow_id = 2;    // 工作流ID
    string run_id = 3;         // 运行ID
    bool success = 4;          // 是否成功
    string error_message = 5;  // 错误信息(如果失败)
  }
  repeated Result results = 1; // 每个任务的创建结果
}

message ScheduleOptions {
  string ID = 1; // ID - The business identifier of the schedule.
  ScheduleSpec Spec = 2; // Schedule - Describes when Actions should be taken.
  ScheduleWorkflowAction Action = 3; // Action - Which Action to take.
  // Overlap - Controls what happens when an Action would be started by a Schedule at the same time that an older Action is still
  // running. This can be changed after a Schedule has taken some Actions, and some changes might produce
  // unintuitive results. In general, the later policy overrides the earlier policy.
  //
  // Optional: defaulted to SCHEDULE_OVERLAP_POLICY_SKIP
  ScheduleOverlapPolicy Overlap = 4;
  string Note = 5;
}

message ScheduleSpec {
  repeated ScheduleCalendarSpec Calendars =1;
}

message  ScheduleCalendarSpec {
  // Second range to match (0-59).
  //
  // default: matches 0
  repeated ScheduleRange Second=1;

  // Minute range to match (0-59).
  //
  // default: matches 0
  repeated ScheduleRange Minute=2;

  // Hour range to match (0-23).
  //
  // default: matches 0
  repeated ScheduleRange Hour=3;

  // DayOfMonth range to match (1-31)
  //
  // default: matches all days
  repeated ScheduleRange DayOfMonth=4;

  // Month range to match (1-12)
  //
  // default: matches all months
  repeated ScheduleRange Month=5;

  // Year range to match.
  //
  // default: empty that matches all years
  repeated ScheduleRange Year=6;

  // DayOfWeek range to match (0-6; 0 is Sunday)
  //
  // default: matches all days of the week
  repeated ScheduleRange DayOfWeek=7;

  // Comment - Description of the intention of this schedule.
  string Comment =8;
}

message ScheduleRange {
  // Start of the range (inclusive)
  int64 Start=1;

  // End of the range (inclusive)
  //
  // Optional: defaulted to Start
  int64 End=2;

  // Step to be take between each value
  //
  // Optional: defaulted to 1
  int64 Step=3;
}

message ScheduleWorkflowAction {
  // ID - The business identifier of the workflow execution.
  // The workflow ID of the started workflow may not match this exactly,
  // it may have a timestamp appended for uniqueness.
  //
  // Optional: defaulted to a uuid.
  string ID = 1;

  // Workflow - What workflow to run.
  // Workflow can either be the function or workflow type name as a string.
  // On ScheduleHandle.Describe() or ScheduleHandle.Update() it will be the workflow type name.
  string Workflow = 2;

  // Args - Arguments to pass to the workflow.
  // On ScheduleHandle.Describe() or ScheduleHandle.Update() Args will be returned as *commonpb.Payload.
  bytes Args = 3;

  // TaskQueue - The workflow tasks of the workflow are scheduled on the queue with this name.
  // This is also the name of the activity task queue on which activities are scheduled.
  string TaskQueue = 4;

  // WorkflowExecutionTimeout - The timeout for duration of workflow execution. (seconds)
  int64 WorkflowExecutionTimeout = 5;

  // WorkflowRunTimeout - The timeout for duration of a single workflow run.
  int64 WorkflowRunTimeout = 6;

  // WorkflowTaskTimeout - The timeout for processing workflow task from the time the worker
  // pulled this task.
  int64 WorkflowTaskTimeout = 7;

  // RetryPolicy - Retry policy for workflow. If a retry policy is specified, in case of workflow failure
  // server will start new workflow execution if needed based on the retry policy.
  RetryPolicy RetryPolicy = 8;

}

enum ScheduleOverlapPolicy {
    SCHEDULE_OVERLAP_POLICY_UNSPECIFIED = 0;
    SCHEDULE_OVERLAP_POLICY_SKIP = 1;
    SCHEDULE_OVERLAP_POLICY_BUFFER_ONE = 2;
    SCHEDULE_OVERLAP_POLICY_BUFFER_ALL = 3;
    SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER = 4;
    SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER = 5;
    SCHEDULE_OVERLAP_POLICY_ALLOW_ALL = 6;
}

